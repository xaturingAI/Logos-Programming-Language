//! Actor model implementation for the Logos programming language
//! Provides Erlang-inspired actor model with message passing, fault tolerance, and location transparency

use std::collections::HashMap;
use std::sync::mpsc::{self, Sender, Receiver};
use std::sync::{Arc, Mutex, RwLock};
use std::thread;
use std::any::Any;
use std::fmt::Debug;

/// Message trait that all messages must implement
pub trait Message: Send + 'static {
    fn as_any(&self) -> &dyn Any;
}

impl<T: Send + 'static> Message for T {
    fn as_any(&self) -> &dyn Any {
        self
    }
}

/// Actor ID type
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ActorId {
    id: String,
}

impl ActorId {
    pub fn new(id: &str) -> Self {
        ActorId { id: id.to_string() }
    }
}

/// Actor address for sending messages to actors
#[derive(Clone)]
pub struct ActorAddr {
    sender: Sender<Box<dyn Message>>,
    id: ActorId,
}

impl ActorAddr {
    pub fn new(sender: Sender<Box<dyn Message>>, id: ActorId) -> Self {
        ActorAddr { sender, id }
    }

    pub fn send<M: Message>(&self, message: M) -> Result<(), ActorError> {
        self.sender
            .send(Box::new(message))
            .map_err(|_| ActorError::new("Failed to send message to actor"))
    }

    pub fn id(&self) -> &ActorId {
        &self.id
    }
}

/// Actor behavior trait that defines how an actor processes messages
pub trait ActorBehavior: Send {
    fn receive(&mut self, ctx: &ActorContext, message: Box<dyn Message>) -> Result<(), ActorError>;
    fn on_start(&mut self, _ctx: &ActorContext) -> Result<(), ActorError> { Ok(()) }
    fn on_stop(&mut self, _ctx: &ActorContext) -> Result<(), ActorError> { Ok(()) }
    fn on_restart(&mut self, _ctx: &ActorContext) -> Result<(), ActorError> { Ok(()) }
}

/// Actor context that provides information and utilities to the actor
pub struct ActorContext {
    pub myself: ActorAddr,
    pub system: ActorSystemHandle,
}

impl ActorContext {
    pub fn new(myself_addr: ActorAddr, system: ActorSystemHandle) -> Self {
        ActorContext {
            myself: myself_addr,
            system,
        }
    }

    /// Spawns a child actor
    pub fn spawn_child<A: ActorBehavior + 'static>(
        &self,
        id: &str,
        behavior: A,
    ) -> Result<ActorAddr, ActorError> {
        self.system.spawn_actor(id, behavior)
    }

    /// Links the current actor to another actor for failure propagation
    pub fn link(&self, other: &ActorAddr) -> Result<(), ActorError> {
        self.system.link_actors(&self.myself.id(), other.id())
    }
}

/// Actor system that manages all actors
pub struct ActorSystem {
    actors: Arc<RwLock<HashMap<ActorId, ActorHandle>>>,
    links: Arc<RwLock<HashMap<ActorId, Vec<ActorId>>>>,
    system_sender: Sender<SystemMessage>,
    system_receiver: Arc<Mutex<Receiver<SystemMessage>>>,
    /// Supervision strategy for handling failures
    supervisor_strategy: SupervisorStrategy,
}

impl ActorSystem {
    pub fn new(strategy: SupervisorStrategy) -> Self {
        let (sys_tx, sys_rx) = mpsc::channel();

        ActorSystem {
            actors: Arc::new(RwLock::new(HashMap::new())),
            links: Arc::new(RwLock::new(HashMap::new())),
            system_sender: sys_tx,
            system_receiver: Arc::new(Mutex::new(sys_rx)),
            supervisor_strategy: strategy,
        }
    }

    pub fn spawn_actor<A: ActorBehavior + 'static>(
        &self,
        id: &str,
        mut behavior: A,
    ) -> Result<ActorAddr, ActorError> {
        let actor_id = ActorId::new(id);
        
        // Check if actor already exists
        {
            let actors = self.actors.read()
                .map_err(|_| ActorError::new("Failed to acquire read lock on actors"))?;
            if actors.contains_key(&actor_id) {
                return Err(ActorError::new(&format!("Actor with id '{}' already exists", id)));
            }
        }

        // Create channel for actor communication
        let (tx, rx) = mpsc::channel();
        let addr = ActorAddr::new(tx, actor_id.clone());
        
        // Create actor context
        let ctx = ActorContext::new(addr.clone(), ActorSystemHandle {
            actors: self.actors.clone(),
            links: self.links.clone(),
            system_sender: self.system_sender.clone(),
        });
        
        // Start the actor behavior in a new thread
        let actor_thread = thread::spawn(move || {
            // Call on_start when the actor starts
            if let Err(e) = behavior.on_start(&ctx) {
                eprintln!("Actor {} failed to start: {}", id, e);
                return;
            }

            // Process messages in a loop
            loop {
                match rx.recv() {
                    Ok(message) => {
                        if let Err(e) = behavior.receive(&ctx, message) {
                            eprintln!("Actor {} failed to process message: {}", id, e);

                            // Notify system about the failure
                            let _ = ctx.system.system_sender.send(SystemMessage::ActorFailed(ctx.myself.id().clone()));

                            // For now, just try to restart the actor
                            if let Err(e) = behavior.on_restart(&ctx) {
                                eprintln!("Actor {} failed to restart: {}", id, e);
                                break;
                            }
                        }
                    }
                    Err(_) => {
                        // Channel closed, actor should stop
                        break;
                    }
                }
            }

            // Call on_stop when the actor stops
            if let Err(e) = behavior.on_stop(&ctx) {
                eprintln!("Actor {} failed to stop cleanly: {}", id, e);
            }
        });
        
        // Store actor handle
        let handle = ActorHandle {
            addr: addr.clone(),
            thread: Some(actor_thread),
        };
        
        {
            let mut actors = self.actors.write()
                .map_err(|_| ActorError::new("Failed to acquire write lock on actors"))?;
            actors.insert(actor_id, handle);
        }
        
        Ok(addr)
    }

    pub fn get_actor(&self, id: &ActorId) -> Option<ActorAddr> {
        let actors = self.actors.read().ok()?;
        let handle = actors.get(id)?;
        Some(handle.addr.clone())
    }

    pub fn stop_actor(&self, id: &ActorId) -> Result<(), ActorError> {
        let mut actors = self.actors.write()
            .map_err(|_| ActorError::new("Failed to acquire write lock on actors"))?;
        
        if let Some(mut handle) = actors.remove(id) {
            // Drop the sender to close the channel and stop the actor
            drop(handle.addr.sender.clone());
            
            // Wait for the thread to finish
            if let Some(thread) = handle.thread.take() {
                if let Err(e) = thread.join() {
                    return Err(ActorError::new(&format!("Failed to join actor thread: {:?}", e)));
                }
            }
        }
        
        Ok(())
    }

    pub fn link_actors(&self, actor1: &ActorId, actor2: &ActorId) -> Result<(), ActorError> {
        let mut links = self.links.write()
            .map_err(|_| ActorError::new("Failed to acquire write lock on links"))?;
        
        // Add bidirectional links
        links.entry(actor1.clone()).or_default().push(actor2.clone());
        links.entry(actor2.clone()).or_default().push(actor1.clone());
        
        Ok(())
    }

    pub fn run_system(&self) -> Result<(), ActorError> {
        loop {
            let system_msg = self.system_receiver.lock()
                .map_err(|_| ActorError::new("Failed to acquire lock on system receiver"))?
                .recv()
                .map_err(|_| ActorError::new("Failed to receive system message"))?;
            
            match system_msg {
                SystemMessage::ActorFailed(failed_id) => {
                    // Handle actor failure based on linking
                    let links = self.links.read()
                        .map_err(|_| ActorError::new("Failed to acquire read lock on links"))?;
                    
                    if let Some(linked_actors) = links.get(&failed_id) {
                        for linked_id in linked_actors {
                            // Stop linked actors or restart them based on supervision strategy
                            self.stop_actor(linked_id).unwrap_or_else(|e| {
                                eprintln!("Failed to stop linked actor {}: {}", linked_id.id, e);
                            });
                        }
                    }
                    
                    // Remove the failed actor's links
                    let mut links = self.links.write()
                        .map_err(|_| ActorError::new("Failed to acquire write lock on links"))?;
                    links.remove(&failed_id);
                }
            }
        }
    }
}

/// Actor system handle for use within actors
#[derive(Clone)]
pub struct ActorSystemHandle {
    actors: Arc<RwLock<HashMap<ActorId, ActorHandle>>>,
    links: Arc<RwLock<HashMap<ActorId, Vec<ActorId>>>>,
    system_sender: Sender<SystemMessage>,
}

impl ActorSystemHandle {
    pub fn spawn_actor<A: ActorBehavior + 'static>(
        &self,
        id: &str,
        behavior: A,
    ) -> Result<ActorAddr, ActorError> {
        // This is a simplified version - in a real implementation, we'd need to communicate
        // with the main system thread to spawn the actor
        Err(ActorError::new("Spawning actors from within actors not implemented in this simplified version"))
    }

    pub fn get_actor(&self, id: &ActorId) -> Option<ActorAddr> {
        let actors = self.actors.read().ok()?;
        let handle = actors.get(id)?;
        Some(handle.addr.clone())
    }

    pub fn link_actors(&self, actor1: &ActorId, actor2: &ActorId) -> Result<(), ActorError> {
        let mut links = self.links.write()
            .map_err(|_| ActorError::new("Failed to acquire write lock on links"))?;
        
        // Add bidirectional links
        links.entry(actor1.clone()).or_default().push(actor2.clone());
        links.entry(actor2.clone()).or_default().push(actor1.clone());
        
        Ok(())
    }
}

/// Internal system messages
#[derive(Debug)]
enum SystemMessage {
    ActorFailed(ActorId),
}

/// Actor handle to manage actor lifecycle
struct ActorHandle {
    addr: ActorAddr,
    thread: Option<thread::JoinHandle<()>>,
}

/// Actor error type
#[derive(Debug)]
pub struct ActorError {
    details: String,
}

impl ActorError {
    pub fn new(msg: &str) -> Self {
        ActorError {
            details: msg.to_string(),
        }
    }
}

impl std::fmt::Display for ActorError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{}", self.details)
    }
}

impl std::error::Error for ActorError {}

/// Supervisor strategy for handling actor failures
#[derive(Debug, Clone)]
pub enum SupervisorStrategy {
    OneForOne,    // Restart only the failed child
    OneForAll,    // Restart all children
    RestForOne,   // Restart the failed child and all siblings started after it
    Eventual,     // Eventually consistent - allow failures to propagate
}

/// Default actor implementation for convenience
pub struct DefaultActor {
    pub name: String,
    pub message_handler: Box<dyn Fn(&ActorContext, Box<dyn Message>) -> Result<(), ActorError> + Send>,
}

impl DefaultActor {
    pub fn new<F>(name: &str, handler: F) -> Self
    where
        F: Fn(&ActorContext, Box<dyn Message>) -> Result<(), ActorError> + Send + 'static,
    {
        DefaultActor {
            name: name.to_string(),
            message_handler: Box::new(handler),
        }
    }
}

impl ActorBehavior for DefaultActor {
    fn receive(&mut self, ctx: &ActorContext, message: Box<dyn Message>) -> Result<(), ActorError> {
        (self.message_handler)(ctx, message)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[derive(Debug)]
    struct TestMessage {
        content: String,
    }

    #[test]
    fn test_actor_system() {
        let system = ActorSystem::new();
        
        // Create a simple actor that echoes messages
        let echo_actor = DefaultActor::new("echo_actor", |_ctx, msg: Box<dyn Message>| {
            // In a real test, we would process the message
            println!("Echo actor received message");
            Ok(())
        });
        
        let addr = system.spawn_actor("echo_actor", echo_actor).unwrap();
        
        // Send a test message
        let test_msg = TestMessage {
            content: "Hello, Actor!".to_string(),
        };
        
        assert!(addr.send(test_msg).is_ok());
        
        // Clean up
        system.stop_actor(&ActorId::new("echo_actor")).unwrap();
    }
}